io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/Close1.kt:17:                is InputChannel<*> -> {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/Close1.kt:22:                is OutputChannel<*> -> {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:138:                is InputChannel<*> -> {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:147:                is OutputChannel<*> -> {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:211:            is Var -> null
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:249:            is Var -> return this
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:250:            is Struct -> {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:264:        if (term !is Atom) {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:288:            is Var -> return null
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:289:            is Struct -> when {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:307:            is Var -> this
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:308:            is Atom -> when {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:320:            term is Var -> this
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:321:            term !is Integer -> ensuringArgumentIsInteger(index)
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:333:            term is Atom -> {
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:357:            is InputChannel<String> -> channel
io-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/io/primitives/IOPrimitiveUtils.kt:363:            is OutputChannel<String> -> channel
io-lib/src/commonTest/kotlin/it/unibo/tuprolog/solve/libs/io/TestConsultImpl.kt:28:                assertTrue { solutions.single() is Solution.Yes }
io-lib/src/commonTest/kotlin/it/unibo/tuprolog/solve/libs/io/TestConsultImpl.kt:50:                    assertTrue { it is Solution.Halt }
io-lib/src/commonTest/kotlin/it/unibo/tuprolog/solve/libs/io/TestConsultImpl.kt:52:                    assertTrue { solution.exception is SyntaxError }
io-lib/src/commonTest/kotlin/it/unibo/tuprolog/solve/libs/io/TestConsultImpl.kt:75:                    assertTrue { it is Solution.Halt }
io-lib/src/commonTest/kotlin/it/unibo/tuprolog/solve/libs/io/TestConsultImpl.kt:77:                    assertTrue { solution.exception is SystemError }
io-lib/src/commonTest/kotlin/it/unibo/tuprolog/solve/libs/io/TestIncludeImpl.kt:91:                assertTrue { events[0] is InitializationIssue }
io-lib/src/jsMain/kotlin/it/unibo/tuprolog/solve/libs/io/ChannelUtilsJs.kt:8:    throw IllegalStateException("Reading terms is still not supported for JS")
io-lib/src/jsMain/kotlin/it/unibo/tuprolog/solve/libs/io/FileSystem.kt:64://     throw IOException("Reading a local file in browser is not supported, yet")
io-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/io/ChannelUtilsJvm.kt:14:    if (this !is ReaderChannel) {
io-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/io/ChannelUtilsJvm.kt:15:        throw IllegalStateException("Channel $streamTerm does not supporting reading terms, as it is of type ${this::class.simpleName}")
io-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/io/UrlUtilsJvm.kt:22:    is JvmUrl -> url
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/exceptions/ConstructorInvocationException.kt:17:    "There is no constructor on type ${type.fullName} which accepts " +
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/exceptions/MalformedAliasException.kt:18:    "This is not a dealiasing expression `$dealiasingExpression` in the form ${
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/exceptions/MethodInvocationException.kt:18:    "There is no method on type ${type.fullName} which is named `$missingMethodName` and accepts " +
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/exceptions/NoSuchAnAliasException.kt:16:    "There exists no reference whose alias is `${dealiasingExpression[0]}`"
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/exceptions/NoSuchAnAliasException.kt:21:        require(dealiasingExpression[0] is Struct)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/exceptions/PropertyAssignmentException.kt:18:    "There is no property on type ${type.fullName} which is named `$missingPropertyName` and can be " +
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/exceptions/RuntimePermissionException.kt:23:    } + "is not permitted",
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/ObjectToTermConverterImpl.kt:20:                is String -> Atom.of(source)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/ObjectToTermConverterImpl.kt:21:                is Number -> when {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/ObjectToTermConverterImpl.kt:25:                is Char -> Atom.of(charArrayOf(source).concatToString())
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/ObjectToTermConverterImpl.kt:26:                is Boolean -> Truth.of(source)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:35:            is NullRef, is Var -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:42:            is ObjectRef -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:49:            is Truth -> when {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:54:            is Atom -> when {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:65:            is Real -> when {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:71:            is Integer -> when {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:82:            is Struct ->
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:86:                        is ObjectRef -> convertInto(type, ref)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:112:            is TypeRef -> typeTerm.type
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:113:            is Atom -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:116:            is Struct -> when {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:118:                    is TypeRef -> ref.type
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:141:            is NullRef, is Var -> sequenceOf(Nothing::class)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:142:            is ObjectRef -> sequenceOf(term.`object`::class)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:143:            is Truth -> sequenceOf(Boolean::class, String::class)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:144:            is Atom -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:151:            is Real -> sequenceOf(BigDecimal::class, Double::class, Float::class)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:152:            is Integer -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:175:            is Struct -> when {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TermToObjectConverterImpl.kt:178:                    is ObjectRef -> admissibleTypesByPriority(ref)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TypeRefImpl.kt:32:            is Optional.Some<out Any> -> companionObjectRef.value.invoke(objectConverter, methodName, arguments)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/TypeRefImpl.kt:59:            is Optional.Some<out Any> -> companionObjectRef.value.assign(objectConverter, propertyName, value)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/AbstractInvoke.kt:27:                is Ref -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/AbstractInvoke.kt:30:                is Struct -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/AbstractInvoke.kt:41:            is Result.Value -> resultTerm mguWith result.getInvocationResult()
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/AbstractIterableItems.kt:27:            first is Var && second is Var ->
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/AbstractIterableItems.kt:29:            second is List -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/AbstractIterableItems.kt:35:            first is ObjectRef -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/ArrayItems.kt:7:        get() = this is Array<*>
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/Assign.kt:24:                is Ref -> first
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/Cast.kt:22:                is Struct -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/Cast.kt:31:                is Var -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/ListItems.kt:7:        get() = this is List<*>
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/NullRef.kt:9:    override fun testType(term: Term): Boolean = term is NullRefTerm
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/ObjectRef.kt:9:    override fun testType(term: Term): Boolean = term is ObjectRefTerm
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:32:    get() = this is Struct && this matches DEALIASING_TEMPLATE && args[0] is Atom
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:39:        arg is Struct && arg matches DEALIASING_TEMPLATE && ensureAliasIsRegistered(arg) -> this
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:40:        arg !is Ref -> throw TypeError.forArgument(context, signature, TypeError.Expected.REFERENCE, arg, index)
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:48:        arg is Struct && arg matches DEALIASING_TEMPLATE && findRefFromAlias(arg) is ObjectRef -> this
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:49:        arg !is ObjectRef -> throw TypeError.forArgument(
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:63:        arg is Struct && arg matches DEALIASING_TEMPLATE && findRefFromAlias(arg) is TypeRef -> this
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:64:        arg !is TypeRef -> throw TypeError.forArgument(
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:79:        arg is TypeRef -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:82:        arg is Atom -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/PrimitiveExtensions.kt:85:        arg is Struct && arg.isDealiasingExpression -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/Ref.kt:9:    override fun testType(term: Term): Boolean = term is RefTerm
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/SetItems.kt:7:        get() = this is Set<*>
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/Type.kt:24:            first is Var && second is Var -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/Type.kt:28:            first is Var -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/Type.kt:33:            second is Var -> {
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/primitives/TypeRef.kt:9:    override fun testType(term: Term): Boolean = term is TypeRefTerm
oop-lib/src/commonMain/kotlin/it/unibo/tuprolog/solve/libs/oop/Result.kt:30:                if (it is ObjectRef) it else ObjectRef.of(value)
oop-lib/src/jsMain/kotlin/it/unibo/tuprolog/solve/libs/oop/TypeUtilsJs.kt:9:private val TODO_EXCEPTION = NotImplementedError("OOP-Prolog integration is still not supported on JS")
oop-lib/src/jsMain/kotlin/it/unibo/tuprolog/solve/libs/oop/TypeUtilsJs.kt:20:        "`$qualifiedName` should match ${CLASS_NAME_PATTERN.pattern}, while is doesn't"
oop-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/OverloadSelectorImpl.kt:69:                is KClass<*> -> {
oop-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/oop/impl/OverloadSelectorImpl.kt:72:                is KTypeParameter -> {
oop-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/oop/TypeUtilsJvm.kt:116:    if (this is KClass<*>) {
oop-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/oop/TypeUtilsJvm.kt:132:        is KProperty0<T> -> get()
oop-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/oop/TypeUtilsJvm.kt:133:        is KProperty1<*, T> -> {
oop-lib/src/jvmMain/kotlin/it/unibo/tuprolog/solve/libs/oop/TypeUtilsJvm.kt:137:        is KProperty2<*, *, T> -> {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestAliasImpl.kt:27:            is KClass<*> -> TypeRef.of(obj)
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestCreationImpl.kt:32:                is Solution.Halt -> when (val exception = solution.exception) {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestCreationImpl.kt:33:                    is SystemError -> {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestCreationImpl.kt:34:                        assertTrue(exception.cause is OopRuntimeException)
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestCreationImpl.kt:35:                        assertTrue(exception.cause?.cause is NullPointerException)
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestCreationImpl.kt:37:                    is RepresentationError -> {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestCreationImpl.kt:38:                        assertTrue(exception.cause is TermToObjectConversionException)
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestCreationImpl.kt:42:                is Solution.Yes -> solver.solveOnce(query).substitution[X]?.let {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestCreationImpl.kt:43:                    assertTrue(it is ObjectRef)
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestInvocationImpl.kt:42:                is Solution.Halt -> when (val exception = solution.exception) {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestInvocationImpl.kt:43:                    is SystemError -> {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestInvocationImpl.kt:44:                        assertTrue(exception.cause is OopRuntimeException)
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestInvocationImpl.kt:45:                        assertTrue(exception.cause?.cause is NullPointerException)
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestInvocationImpl.kt:47:                    is RepresentationError -> {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestInvocationImpl.kt:48:                        assertTrue(exception.cause is TermToObjectConversionException)
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestInvocationImpl.kt:52:                is Solution.Yes -> {
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestKotlinReflectionWorkaroundsAreStillNecessary.kt:23:            assertTrue("Expected exception type ${T::class}, actual: ${e::class}") { e is T }
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestRefs.kt:31:                assertTrue { result is Result.Value }
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestRefs.kt:35:                assertTrue { case.term.let { it is Var || it is NullRef } }
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestRefs.kt:60:                assertTrue { result is Result.Value }
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestRefs.kt:61:                assertTrue { result.asObjectRef()?.`object` is ConstructorOverloadDetector }
oop-lib/src/jvmTest/kotlin/it/unibo/tuprolog/solve/libs/oop/TestRefs.kt:65:                assertTrue { case.term.let { it is Var || it is NullRef } }
parser-core/src/commonMain/kotlin/it/unibo/tuprolog/core/parsing/TermParserExtensions.kt:26:        is Clause -> this
parser-core/src/commonMain/kotlin/it/unibo/tuprolog/core/parsing/TermParserExtensions.kt:27:        is Struct -> Fact.of(this)
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/AssertionUtils.kt:28:            expected is Var && actual is Var -> {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/AssertionUtils.kt:31:            expected is Constant && actual is Constant -> {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/AssertionUtils.kt:34:            expected is Struct && actual is Struct -> {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:127:        "element_at(X,[_|L],K) :- K > 1, K1 is K - 1, element_at(X,L,K1)" to prolog {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:129:                (("K" greaterThan 1) and (("K1" `is` ("K" - 1)) and ("element_at"("X", "L", "K1"))))
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:134:        "my_length([_|L],N) :- my_length(L,N1), N is N1 + 1" to prolog {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:136:                ("my_length"("L", "N1") and (("N" `is` ("N1".toTerm() + 1))))
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:180:        "count(X,[X|Xs],Ys,K,T) :- K1 is K + 1, count(X,Xs,Ys,K1,T)" to prolog {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:182:                (("K1" `is` ("K".toTerm() + 1)) and ("count"("X", "Xs", "Ys", "K1", "T")))
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:184:        "map_upper_bound(XMax, YMax) :- map_size(XSize, YSize), XMax is XSize - 1, YMax is YSize - 1" to prolog {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:186:                ("map_size"("XSize", "YSize") and (("XMax" `is` ("XSize" - 1)) and ("YMax" `is` ("YSize" - 1))))
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:196:        "draw_char(X, Y) :- tty_size(_, XSize), X >= XSize, NY is Y + 1, draw_char(0, NY)" to prolog {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:198:                ("tty_size"(`_`, "XSize") and (("X" greaterThanOrEqualsTo "XSize") and (("NY" `is` ("Y".toTerm() + 1)) and ("draw_char"(0, "NY")))))
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:200:        "Y < YMsgs -> write(' ') ; display_offset(XOff, YOff), XMap is X + XOff, YMap is Y + YOff, get_character(XMap, YMap, C), format('~s', [C])" to prolog {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:204:                        ("XMap" `is` ("X".toTerm() + "XOff")) and (
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:205:                            ("YMap" `is` ("Y".toTerm() + "YOff")) and
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:211:        "display_offset(X, Y) :- player(XPos, YPos), tty_size(YSize, XSize), message_lines(YMsgs), X is XPos - floor(XSize / 2), Y is YPos - floor((YSize - YMsgs) / 2)" to prolog {
parser-core/src/commonTest/kotlin/it/unibo/tuprolog/core/parsing/test/ParsingExamples.kt:217:                                ("X" `is` ("XPos" - "floor"("XSize" / 2))) and (("Y" `is` ("YPos" - "floor"(("YSize" - "YMsgs") / 2))))
parser-core/src/jsMain/kotlin/it/unibo/tuprolog/core/parsing/DynamicOpListener.kt:30:            if (op is Struct && op.arity == 3 && op.functor == "op" && op[0] is Numeric && op[1] is Atom && op.isGround) {
parser-core/src/jsMain/kotlin/it/unibo/tuprolog/core/parsing/DynamicOpListener.kt:34:                    is Atom -> {
parser-core/src/jsMain/kotlin/it/unibo/tuprolog/core/parsing/DynamicOpListener.kt:37:                    is LogicList -> {
parser-core/src/jsMain/kotlin/it/unibo/tuprolog/core/parsing/DynamicOpListener.kt:38:                        if (operator.toSequence().all { it is Atom }) {
parser-core/src/jsMain/kotlin/it/unibo/tuprolog/core/parsing/PrologParserFactory.kt:24:                return if (obj is Token) {
parser-core/src/jsMain/kotlin/it/unibo/tuprolog/core/parsing/PrologParserFactory.kt:40:                if (recognizer is PrologParser) {
parser-core/src/jvmMain/kotlin/it/unibo/tuprolog/core/parsing/DynamicOpListener.kt:32:            if (op is Struct && op.arity == 3 && op.functor == "op" && op[0] is Numeric && op[1] is Atom && op.isGround) {
parser-core/src/jvmMain/kotlin/it/unibo/tuprolog/core/parsing/DynamicOpListener.kt:42:                    is Atom -> {
parser-core/src/jvmMain/kotlin/it/unibo/tuprolog/core/parsing/DynamicOpListener.kt:45:                    is LogicList -> {
parser-core/src/jvmMain/kotlin/it/unibo/tuprolog/core/parsing/DynamicOpListener.kt:46:                        if (operator.toSequence().all { it is Atom }) {
parser-core/src/jvmMain/kotlin/it/unibo/tuprolog/core/parsing/PrologParserFactory.kt:28:                return if (obj is Token) {
parser-core/src/jvmMain/kotlin/it/unibo/tuprolog/core/parsing/PrologParserFactory.kt:43:                if (recognizer is PrologParser) {
parser-core/src/jvmMain/kotlin/it/unibo/tuprolog/core/parsing/PrologParserFactory.kt:172:                ex.cause is RecognitionException -> {
parser-core/src/jvmMain/kotlin/it/unibo/tuprolog/core/parsing/PrologParserFactory.kt:203:                ex.cause is RecognitionException -> throw ex.cause as RecognitionException
parser-js/src/test/kotlin/it/unibo/tuprolog/parser/TestLexerKt.kt:106:        val input = "_ + A + _B is _1 + _a + _+"
parser-js/src/test/kotlin/it/unibo/tuprolog/parser/TestLexerKt.kt:109:        lexer.addOperators("+", "is")
parser-js/src/test/kotlin/it/unibo/tuprolog/parser/TestLexerKt.kt:136:            assertEquals("is", it.text)
parser-js/src/test/kotlin/it/unibo/tuprolog/parser/TestLexerKt.kt:167:        val input = "1 ? a is c :- d"
parser-js/src/test/kotlin/it/unibo/tuprolog/parser/TestLexerKt.kt:170:        lexer.addOperators("?", "is", ":-")
parser-js/src/test/kotlin/it/unibo/tuprolog/parser/TestLexerKt.kt:189:            assertEquals("is", it.text)
repl/src/commonMain/kotlin/it/unibo/tuprolog/ui/repl/TuPrologUtils.kt:17:            is Solution.Yes -> {
repl/src/commonMain/kotlin/it/unibo/tuprolog/ui/repl/TuPrologUtils.kt:20:            is Solution.No -> {
repl/src/commonMain/kotlin/it/unibo/tuprolog/ui/repl/TuPrologUtils.kt:23:            is Solution.Halt -> {
repl/src/commonMain/kotlin/it/unibo/tuprolog/ui/repl/TuPrologUtils.kt:35:            is HaltException -> {
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeobjectifier.kt:15:            is Boolean -> deobjectifyBoolean(`object`)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeobjectifier.kt:16:            is Int, Long, Short, Byte, Float, Double -> deobjectifyNumber(`object`)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeobjectifier.kt:17:            is String -> deobjectifyString(`object`)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeobjectifier.kt:24:            is Array<*> -> `object`.map { deobjectify(it ?: throw DeobjectificationException(`object`)) }
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeobjectifier.kt:45:            is String -> scope.realOf(actualValue as String)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeobjectifier.kt:46:            is Double -> scope.realOf(actualValue as Double)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeobjectifier.kt:53:            is String -> scope.intOf(actualValue as String)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeobjectifier.kt:54:            is Int -> scope.intOf(actualValue as Int)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeserializer.kt:14:            is MimeType.Xml -> throw NotImplementedError("XML is currently not supported in JS")
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeserializer.kt:15:            is MimeType.Json -> JSON.parse(string)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermDeserializer.kt:16:            is MimeType.Yaml -> YAML.parse(string)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermSerializer.kt:17:            is MimeType.Xml -> throw NotImplementedError("XML is currently not supported in JS")
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermSerializer.kt:18:            is MimeType.Json -> JSON.stringify(objectified)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTermSerializer.kt:19:            is MimeType.Yaml -> YAML.stringify(objectified)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/ObjectsUtils.kt:7:            is MimeType.Xml -> throw NotImplementedError()
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/ObjectsUtils.kt:8:            is MimeType.Yaml -> YAML.parse(string)
serialize-core/src/jsMain/kotlin/it/unibo/tuprolog/serialize/ObjectsUtils.kt:9:            is MimeType.Json -> JSON.parse(string)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:18:            is Boolean -> deobjectifyBoolean(`object`)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:19:            is Number -> deobjectifyNumber(`object`)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:20:            is String -> deobjectifyString(`object`)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:21:            is Map<*, *> -> deobjectifyMap(`object`)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:28:            is List<*> -> `object`.map { deobjectify(it ?: throw DeobjectificationException(`object`)) }
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:49:            is String -> scope.realOf(actualValue)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:50:            is Number -> deobjectifyNumber(actualValue) as? Real ?: throw DeobjectificationException(value)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:57:            is String -> scope.intOf(actualValue)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:58:            is Number -> deobjectifyNumber(actualValue) as? LogicInteger ?: throw DeobjectificationException(value)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:130:            is Int -> scope.numOf(value)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:131:            is Long -> scope.numOf(value)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:132:            is Double -> scope.numOf(value)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:133:            is Byte -> scope.numOf(value)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:134:            is Short -> scope.numOf(value)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:135:            is Float -> scope.numOf(value)
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:136:            is BigInteger -> LogicInteger.of(value.toString())
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTermDeobjectifier.kt:137:            is BigDecimal -> Real.of(value.toString())
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/ObjectsUtils.kt:10:            obj1 is Number && obj2 is Number -> obj1.toString() == obj2.toString()
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/ObjectsUtils.kt:11:            obj1 is List<*> && obj2 is List<*> -> when {
serialize-core/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/ObjectsUtils.kt:17:            obj1 is Map<*, *> && obj2 is Map<*, *> -> when {
serialize-theory/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTheoryDeobjectifier.kt:17:            is Array<*> -> `object`.map { deobjectify(it ?: throw DeobjectificationException(`object`)) }
serialize-theory/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTheoryDeserializer.kt:14:            is MimeType.Xml -> throw NotImplementedError("XML is currently not supported in JS")
serialize-theory/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTheoryDeserializer.kt:15:            is MimeType.Json -> JSON.parse(string)
serialize-theory/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTheoryDeserializer.kt:16:            is MimeType.Yaml -> YAML.parse(string)
serialize-theory/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTheorySerializer.kt:17:            is MimeType.Xml -> throw NotImplementedError("XML is currently not supported in JS")
serialize-theory/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTheorySerializer.kt:18:            is MimeType.Json -> JSON.stringify(objectified)
serialize-theory/src/jsMain/kotlin/it/unibo/tuprolog/serialize/JsTheorySerializer.kt:19:            is MimeType.Yaml -> YAML.stringify(objectified)
serialize-theory/src/jvmMain/kotlin/it/unibo/tuprolog/serialize/JvmTheoryDeobjectifier.kt:17:            is List<*> -> `object`.map { deobjectify(it ?: throw DeobjectificationException(`object`)) }
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/ChoicePointContext.kt:15:// This assertion fails on JS since depth is undefined
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/EndState.kt:13:        get() = solution is Solution.Yes && context.hasOpenAlternatives
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateException.kt:26:            is MessageError -> content
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateException.kt:33:            is MessageError -> SystemError.forUncaughtError(this)
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateException.kt:51:            is PrologError -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateException.kt:55:                    catchGoal is Struct && catchGoal.isCatch() -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateException.kt:59:                            catcher is Substitution.Unifier -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StatePrimitiveExecution.kt:29:            is Solution.Yes -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StatePrimitiveExecution.kt:38:            is Solution.No -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StatePrimitiveExecution.kt:41:            is Solution.Halt -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StatePrimitiveSelection.kt:25:                is Var -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StatePrimitiveSelection.kt:34:                is Struct -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateRuleExecution.kt:15:            is Substitution.Unifier -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateRuleSelection.kt:89:    private fun Term.isCut(): Boolean = this is Atom && value == "!"
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateRuleSelection.kt:109:            cutLimit is CutLimit.None ||
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateRuleSelection.kt:137:            is Var -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateRuleSelection.kt:146:            is Struct -> with(context) {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateRuleSelection.kt:150:                    currentGoal is Truth -> {
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/StateRuleSelection.kt:159:                        val cutLimit = computeCutLimit(currentGoal is MagicCut)
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/Utils.kt:22:    map { require(it is Rule); it as Rule }.cursor()
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/Utils.kt:26:        is Tuple -> toSequence().flatMap { it.unfoldGoals() }
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/fsm/Utils.kt:33:            is Var -> Struct.of("call", it)
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/impl/AbstractSolutionIterator.kt:16:    final override fun hasNext(): Boolean = state.let { it !is EndState || it.hasOpenAlternatives }
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/impl/AbstractSolutionIterator.kt:23:        } while (state !is EndState)
solve-classic/src/commonMain/kotlin/it/unibo/tuprolog/solve/classic/stdlib/primitive/Throw.kt:15:            error is Struct && error.functor == "error" && error.arity in 1..2 -> {
solve-classic/src/commonTest/kotlin/it/unibo/tuprolog/solve/TestStaticFactory.kt:17:        assertTrue { solver is ClassicSolver }
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/channel/impl/AbstractChannel.kt:46:            throw IllegalStateException("Channel is already closed")
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/channel/impl/AbstractInputChannel.kt:15:        get() = if (isClosed) throw IllegalStateException("Input channel is closed") else true
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/channel/impl/AbstractInputChannel.kt:21:        if (isClosed) throw IllegalStateException("Input channel is closed")
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/channel/impl/AbstractInputChannel.kt:30:        if (isClosed) throw IllegalStateException("Input channel is closed")
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/channel/impl/AbstractInputChannel.kt:48:            if (isClosed) throw IllegalStateException("Input channel is closed")
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/channel/impl/AbstractOutputChannel.kt:10:        if (isClosed) throw IllegalStateException("Output channel is closed")
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/channel/impl/AbstractOutputChannel.kt:23:        if (isClosed) throw IllegalStateException("Output channel is closed")
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/ClauseListener.kt:26:            is Directive -> onDirective(clause)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/ClauseListener.kt:27:            is Fact -> onFact(clause)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/ClauseListener.kt:28:            is Rule -> onRule(clause)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/ClausePartitioner.kt:87:        if (name is Atom) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/ClausePartitioner.kt:94:        if (priority is Integer) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/ClausePartitioner.kt:97:                if (name is Atom) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/ClausePartitioner.kt:108:        if (goal is Atom) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/ClausePartitioner.kt:115:        if (goal is Struct) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/directives/DirectiveListener.kt:35:            is Directive -> listenDirective(clause)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/DomainError.kt:14: * The domain error occurs when something has the correct type but the value is not admissible
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/DomainError.kt:107:            "Term `${actualValue.pretty()}` is not a valid $expectedDomain"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/DomainError.kt:126:            "Subgoal `${actualValue.pretty()}` of ${procedure.pretty()} is not $expectedDomain term"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/DomainError.kt:205:                is Atom -> of(term.value)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/ErrorUtils.kt:21:     * For example if the [errorDescription] is `instantiation_error` the corresponding error struct, according to prolog standard, will be
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/ErrorUtils.kt:24:     * If the error [errorDescription] is composite like `type_error(callable, Goal)` the corresponding struct, according to prolog standard, will be
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/EvaluationError.kt:75:                is Atom ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/ExistenceError.kt:14: * The existence error occurs when an object on which an operation is to be performed does not exist
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/ExistenceError.kt:99:            "There exists no stream whose alias is `$alias`"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/ExistenceError.kt:181:                is Atom -> of(term.value)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/InstantiationError.kt:13: * The instantiation error occurs when some Term is a Variable, and it should not
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/InstantiationError.kt:57:                    "of ${procedure.pretty()} is unexpectedly not instantiated"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/MessageError.kt:9: * The [MessageError] is used whenever no other [PrologError] instance is suitable for representing the error
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/PermissionError.kt:14: * A permission error occurs when an attempt to perform a prohibited operation is made
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/PermissionError.kt:74:                "operation of type `$operation` is not possible on $permission: ${culprit.pretty()}"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/PermissionError.kt:124:                is Atom -> of(term.value)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/PermissionError.kt:164:                is Atom -> of(term.value)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/RepresentationError.kt:112:                is Atom -> of(term.value)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/SystemError.kt:73:                is MessageError -> content.pretty()
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/TypeError.kt:15: * The type error occurs when something is not of [Expected] type
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/TypeError.kt:126:            "Subgoal `${culprit.pretty()}` of ${procedure.pretty()} is not a $expectedType term"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/exception/error/TypeError.kt:189:                is Atom -> of(term.value)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/ExecutionContextAware.kt:25:    /** Static Knowledge-base, that is a KB that *can't* change executing goals */
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/ExecutionContextAware.kt:29:    /** Dynamic Knowledge-base, that is a KB that *can* change executing goals */
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/ExecutionContextAware.kt:46:     * Returns `null` if the channel is closed
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/ExecutionContextAware.kt:54:     * Returns `null` if the channel is closed
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/ExecutionContextAware.kt:61:     * Returns `null` if the channel is closed
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/ExecutionContextAware.kt:68:     * Returns `null` if the channel is closed
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/ExecutionContext.kt:16:// TODO: 25/09/2019 solverStrategies should go here... in common with other implementations, if the idea is approved
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/flags/FlagStore.kt:29:            throw IllegalArgumentException("Value $value is not admissible for flag $notableFlag")
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/flags/NotableFlag.kt:34:                "$value is not an admissible value for flag $name"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/AbstractEvaluator.kt:57:     * This is a stub implementation, that does nothing
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/AbstractEvaluator.kt:64:     * This is a stub implementation, that does nothing
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ArithmeticEvaluator.kt:26: * Throws a [TypeError] in case a non-evaluable sub-term is met.
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ArithmeticEvaluator.kt:40:            this is Var ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ArithmeticEvaluator.kt:42:            this is Atom ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ArithmeticEvaluator.kt:44:            this is Struct && this.extractSignature() !in allowedArithmeticSignatures ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ArithmeticEvaluator.kt:52:            // the argument of an arithmetic functor is evaluated to a non-numeric value
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ArithmeticEvaluator.kt:53:            this !is Numeric ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ArithmeticEvaluator.kt:56:            // the argument of a bitwise operator is evaluated to a non-integer value
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ArithmeticEvaluator.kt:57:            this !is Integer && enclosingTerm.extractSignature() in bitwiseStandardOperatorsSignatures ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/BinaryMathFunction.kt:25:                term1 is Integer && term2 is Integer -> mathFunction(term1, term2, context)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/BinaryMathFunction.kt:26:                term1 is Real && term2 is Integer -> mathFunction(term1, term2, context)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/BinaryMathFunction.kt:27:                term1 is Integer && term2 is Real -> mathFunction(term1, term2, context)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/BinaryMathFunction.kt:28:                term1 is Real && term2 is Real -> mathFunction(term1, term2, context)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/BinaryMathFunction.kt:29:                term1 is Var -> throw InstantiationError.forArgument(context, signature, term1, 0)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/BinaryMathFunction.kt:30:                term2 is Var -> throw InstantiationError.forArgument(context, signature, term2, 1)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/Compute.kt:20:        /** Arguments with which the function is invoked in this [Request] */
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ExpressionEvaluator.kt:10: * Throws a [TypeError] in case a non-evaluable sub-term is met.
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/ExpressionReducer.kt:11: * If the input expression is non-evaluable, it remains unaffected and no error is thrown
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/UnaryMathFunction.kt:21:                is Integer -> mathFunction(term, context)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/function/UnaryMathFunction.kt:22:                is Real -> mathFunction(term, context)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/AbstractSolver.kt:118:                is Solution.No -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/AbstractSolver.kt:121:                is Solution.Halt -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionFormatterImpl.kt:12:        is Solution.Yes -> formatYes(value)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionFormatterImpl.kt:13:        is Solution.No -> "no."
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionFormatterImpl.kt:14:        is Solution.Halt -> when (val e = value.exception) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionFormatterImpl.kt:15:            is TimeOutException -> "timeout."
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionFormatterImpl.kt:16:            is HaltException -> "halt: ${e.exitStatus}"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionImpl.kt:36:        if (this is Solution.Yes && yes != null) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionImpl.kt:39:        if (this is Solution.No && no != null) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionImpl.kt:42:        if (this is Solution.Halt && halt != null) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/impl/SolutionImpl.kt:107:            return filter { v, t -> (v in toRetain) || (t !is Var) || (t in toRetain) }
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/library/Library.kt:51:    /** Checks whether the provided signature, is protected in this library */
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/MutableSolver.kt:21: * of the solver -- e.g.  affecting the KB -- while no resolution process is ongoing.
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:119:            arguments.withIndex().firstOrNull { it.value is Var }?.let {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:174:                is Indicator -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:177:                        name is Var -> throw InstantiationError.forArgument(context, signature, name, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:178:                        arity is Var -> throw InstantiationError.forArgument(context, signature, arity, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:179:                        name !is Atom -> throw TypeError.forArgument(context, signature, ATOM, name, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:180:                        arity !is Integer -> throw TypeError.forArgument(context, signature, INTEGER, arity, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:193:            message: String = "Primitive for ${signature.name}/${signature.arity} is not implemented, yet"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:197:            message: String = "Operation ${signature.name}/${signature.arity} is not supported"
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:205:                candidate is Clause -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:211:                candidate is Struct && candidate.functor == Clause.FUNCTOR && candidate.arity == 2 ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:213:                candidate is Struct -> return this
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:223:                !is Numeric -> throw TypeError.forArgument(context, signature, TypeError.Expected.NUMBER, arg, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:229:                !is Struct -> throw TypeError.forArgument(context, signature, TypeError.Expected.CALLABLE, arg, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:238:                !is Var -> throw TypeError.forArgument(
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:250:                !is Struct, is Atom -> throw TypeError.forArgument(
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:262:                !is Atom -> throw TypeError.forArgument(context, signature, ATOM, arg, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:268:                !is Constant -> throw TypeError.forArgument(context, signature, ATOMIC, arg, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:284:                is Atom -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:299:                    arg !is Atom -> throw DomainError.forArgument(context, signature, OPERATOR_SPECIFIER, arg, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:313:                !is Integer -> throw TypeError.forArgument(context, signature, INTEGER, arg, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:319:                !is LogicList -> throw TypeError.forArgument(context, signature, TypeError.Expected.LIST, arg, index)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:338:                    arg !is Integer || arg.intValue < BigInteger.ZERO -> throw DomainError.forArgument(
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:356:                term !is Integer || term.isCharacterCode() ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:363:                term !is LogicList || !term.isWellFormed -> throw DomainError.forTerm(context, WELL_FORMED_LIST, term)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/PrimitiveWrapper.kt:369:                is LogicList -> when {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/Solve.kt:27:        /** Arguments with which the goal is invoked in this [Request] */
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/Solve.kt:64:            is Substitution.Unifier -> replySuccess(substitution, sideEffectManager, *sideEffects)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/primitive/Solve.kt:75:            is Substitution.Unifier -> replySuccess(substitution, sideEffectManager, buildSideEffects)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/sideffects/SideEffect.kt:27:                if (it is Theory) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/sideffects/SideEffect.kt:38:                    is MutableTheory -> it
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/sideffects/SideEffect.kt:39:                    is Theory -> it.toMutableTheory()
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/sideffects/SideEffect.kt:117:                if (it is FlagStore) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/sideffects/SideEffect.kt:168:                is AliasedLibrary -> require(lib.alias == alias)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/sideffects/SideEffect.kt:174:                if (it is AliasedLibrary) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/sideffects/SideEffect.kt:233:                if (it is OperatorSet) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Signature.kt:64:    // for example: if user query is `ciao(1, 2)` with Signature("ciao", 2, false), it should be matched with
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Signature.kt:96:                            it is Struct && it.functor == varargStructFunctor && it.arity == 2 &&
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Signature.kt:111:        } catch (ex: IllegalArgumentException) { // caught when parsed arity is negative
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Signature.kt:118:            is Struct -> fromSignatureTerm(term)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Solution.kt:43:     * @return the current [Solution], casted to [Yes], or `null`, if the current term is not an instance of [Yes]
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Solution.kt:50:     * @throws ClassCastException if the current [Solution] is not an instance of [Yes]
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Solution.kt:58:     * @return the current [Solution], casted to [No], or `null`, if the current term is not an instance of [No]
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Solution.kt:65:     * @throws ClassCastException if the current [Solution] is not an instance of [No]
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Solution.kt:73:     * @return the current [Solution], casted to [Halt], or `null`, if the current term is not an instance of [Halt]
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/Solution.kt:80:     * @throws ClassCastException if the current [Solution] is not an instance of [Halt]
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractAssert.kt:21:            is Clause -> first
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractAssert.kt:22:            is Struct -> Fact.of(first)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractCollectionOf.kt:30:            is Substitution.Unifier -> when (val vars = mgu[VARS]) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractCollectionOf.kt:31:                is Tuple -> vars.toSequence().filterIsInstance<Var>().toSet()
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractCollectionOf.kt:32:                is Var -> setOf(vars)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractCollectionOf.kt:37:        val goal = if (mgu is Substitution.Unifier) mgu[GOAL] else second
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractCollectionOf.kt:41:                    is Solution.Halt -> throw it.exception.pushContext(context)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractGetData.kt:15:            is Var ->
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractGetData.kt:17:                    .filter { (_, v) -> v is Term }
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractGetData.kt:22:            is Atom -> when (val value = data[first.value]) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AbstractGetData.kt:23:                is Term -> sequenceOf(replyWith(second mguWith value))
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Arg.kt:25:                    is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Arg.kt:29:                            sub is Substitution.Unifier
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Arg.kt:34:                    is Integer -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomChars.kt:17:            first is Var && second is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomChars.kt:21:            first is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomChars.kt:26:                        if (it is Atom) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomChars.kt:35:            second is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomCodes.kt:19:            is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomCodes.kt:25:                        is Integer -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomCodes.kt:29:                        is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomCodes.kt:42:                if (second !is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomConcat.kt:23:            third is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomConcat.kt:32:            first is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomConcat.kt:41:            second is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Atomic.kt:9:    override fun testType(term: Term): Boolean = term is Constant
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Atom.kt:8:    override fun testType(term: Term): Boolean = term is it.unibo.tuprolog.core.Atom
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomLength.kt:16:            first is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/AtomLength.kt:20:            second is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Between.kt:29:            is LogicInteger -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Between.kt:33:            is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Callable.kt:9:    override fun testType(term: Term): Boolean = term is Struct
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/CharCode.kt:16:            first is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Clause.kt:24:        if (second !is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Compound.kt:10:        term is Struct && term.arity > 0
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/CurrentOp.kt:25:            it.all { sub -> sub is Substitution.Unifier }
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/CurrentPrologFlag.kt:17:        is Atom, is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/EnsureExecutable.kt:16:            is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Float.kt:9:    override fun testType(term: Term): Boolean = term is Real
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Functor.kt:28:        is Struct -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Functor.kt:29:            if (third !is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Functor.kt:34:        is Numeric -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Functor.kt:35:            if (third !is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Functor.kt:40:        is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Functor.kt:42:                is Atom -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Functor.kt:47:                is Numeric -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Functor.kt:59:                is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Integer.kt:8:    override fun testType(term: Term): Boolean = term is it.unibo.tuprolog.core.Integer
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Is.kt:12: * Implementation of 'is'/2 predicate
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Is.kt:16:object Is : BinaryRelation.Functional<ExecutionContext>("is") {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Natural.kt:15:            is Var -> generateValues().map { replySuccess(Substitution.of(first, it)) }
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Natural.kt:16:            is Integer -> sequenceOf(replyWith(checkValue(first)))
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/NonVar.kt:8:    override fun testType(term: Term): Boolean = term !is it.unibo.tuprolog.core.Var
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/NumberChars.kt:18:            first is Var && second is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/NumberChars.kt:23:            first is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/NumberChars.kt:29:            second is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/NumberCodes.kt:19:            is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/NumberCodes.kt:25:                        is Integer -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/NumberCodes.kt:29:                        is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/NumberCodes.kt:43:                if (second !is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Number.kt:9:    override fun testType(term: Term): Boolean = term is Numeric
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/RetractAll.kt:16:        val clause = if (first is Clause) first else Rule.of(first as Struct, Var.anonymous())
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/RetractAll.kt:19:            is RetractResult.Success -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Retract.kt:20:            is Clause -> first
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Retract.kt:21:            is Struct -> Rule.of(first, Var.anonymous())
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Retract.kt:27:                is Clause -> (first mguWith it) as Substitution.Unifier
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Reverse.kt:15:            first is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Reverse.kt:19:            second is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Sleep.kt:13: * The predicate execution always succeeds, unless the resolution process is halted because of a [TimeOutException].
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Sleep.kt:14: * Furthermore, the resolution of a `sleep(N)` sub-goal is guaranteed to require at least `N` milliseconds
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:21:        return if (fifth is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:24:            if (second is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:25:                if (fourth is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:35:                        if (third is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:52:                        if (third is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:73:                        if (third is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:90:                        if (third is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:99:                        if (third is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:111:                        if (third is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/SubAtom.kt:119:                        if (third is Var) {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Univ.kt:33:            is Struct -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Univ.kt:35:                    is LogicList -> decompose(first, second)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Univ.kt:36:                    is Var -> decompose(first, second)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Univ.kt:42:            is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Univ.kt:44:                    is LogicList -> recompose(first, second)
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Univ.kt:45:                    is Var -> {
solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/Var.kt:8:    override fun testType(term: Term): Boolean = term is it.unibo.tuprolog.core.Var
solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/directives/TestDirectivePartitioning.kt:38:            rule { "h"(X) impliedBy (Y `is` (X - 1) and "h"(Y)) },
solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/directives/TestDirectivePartitioning.kt:44:        { it is Fact && it.head.let { h -> h.functor == name && h.arity == arity } }
solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/TestSolutionMetadata.kt:82:            if (solution is Solution.Yes) {
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/AbstractTimedState.kt:29:        solve.executionMaxDuration == TimeDuration.MAX_VALUE -> behaveTimed() // optimized without check, when maxDuration is infinite
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateEnd.kt:39:    /** The *True* state is reached when a successful computational path has ended */
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateEnd.kt:45:            require(solve.solution is Solution.Yes) { "True end state can be created only with Solution.Yes. Current: `${solve.solution}`" }
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateEnd.kt:49:    /** The *False* state is reached when a failed computational path has ended */
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateEnd.kt:55:            require(solve.solution is Solution.No) { "False end state can be created only with Solution.No. Current: `${solve.solution}`" }
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateEnd.kt:59:    /** The *Halt* state is reached when an [HaltException] is caught, terminating the computation */
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateEnd.kt:65:            require(solve.solution is Solution.Halt) { "Halt end state can be created only with Solution.Halt. Current: `${solve.solution}`" }
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateGoalEvaluation.kt:19: * State responsible of solving a selected Goal, if it is a primitive
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateGoalEvaluation.kt:49:                if (it.solution is Solution.Halt) return@sequence // if halt reached, overall computation should stop
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateInit.kt:25:                // current goal is already demonstrated
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateRuleSelection.kt:72:                            if (subState is FinalState && subState.solve.solution.query == subSolveRequest.query) {
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateRuleSelection.kt:78:                                if (subState !is StateEnd.False || !hasAlternatives || cutNextSiblings) {
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateRuleSelection.kt:92:                                if (subState is StateEnd.Halt) return@sequence // if halt reached, overall computation should stop
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateRuleSelection.kt:93:                            } else yield(it) // return wrapped subState as is, only if not interested in it
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/StateRuleSelection.kt:123:            is Solution.Yes -> copy(substitution = substitution - unusedVariables.asIterable())
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/StateMachineExecutor.kt:19:        // drop(1) is to exclude provided [state] from next states' sequence
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/StateMachineExecutor.kt:26:     * This method is useful when implementing internal computation and
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/StateMachineExecutor.kt:49:        is AlreadyExecutedState -> this.wrappedState
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/SideEffectManagerImpl.kt:23:    /** Valued when this execution context is child of a choicePoint context, indicating a point where to cut */
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/SideEffectManagerImpl.kt:53:     * @param isChoicePointChild whether this solve request is child of a ChoicePoint
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/SideEffectManagerImpl.kt:74:    /** Method that updates clauseScopedParent to include upper scope parents; this is needed to maintain Cut functionality through Response chain */
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/SideEffectManagerImpl.kt:86:     * - if cut was called, and the first "scoped" choice point context is to be cut
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/SideEffectManagerImpl.kt:117:     * That implements expected ISO behaviour, for which *call/1 is said to be opaque (or not transparent) to cut.*
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/SolverUtils.kt:24:/** Check whether the receiver term is a well-formed predication */
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/SolverUtils.kt:30: * For example, the goal `A` is transformed, after preparation for execution, as the Term: `call(A)`
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/SolverUtils.kt:73: * @param isChoicePointChild Whether this new request is considered a child of a Choice Point
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/SolverStrategies.kt:20:    /** Determines "when and what" is considered successfully demonstrated, during solution process */
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/solver/StreamsExecutionContext.kt:121:/** Extension method to get [SideEffectManagerImpl], if this context is of right type*/
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Call.kt:35:                    message = "call/1 argument is neither a Variable nor a well-formed goal",
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Conjunction.kt:54:     * @param accumulatedSubstitutions This is a substitution accumulator, that maintains the diff from the [mainRequest] substitution
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Conjunction.kt:55:     * @param previousResponseSideEffectManager This is the previous response side effect manager, needed to propagate information during execution
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Conjunction.kt:90:                    goalResponse.solution is Solution.Yes &&
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Conjunction.kt:110:                    if (goalResponse.solution !is Solution.No || (!previousGoalsHadAlternatives && !currentHasAlternatives) || cutExecuted) {
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Conjunction.kt:119:            if (cutExecuted || goalResponse.solution is Solution.Halt) {
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Not.kt:25:                    is Solution.Yes -> {
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Not.kt:30:                    is Solution.No -> yield(request.replySuccess(request.context.substitution))
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Throw.kt:29:                    is Substitution.Unifier -> sequenceOf(
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Throw.kt:45:                            // if unhandled error is a PrologError, rethrow outside
solve-streams/src/commonMain/kotlin/it/unibo/tuprolog/solve/streams/stdlib/primitive/Throw.kt:48:                            // if current unhandled exception is some other error, launch it as message
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/primitive/testutils/CallUtils.kt:109:     * A request to test that [Call] limits [Cut] to have effect only inside its goal; `call/1` is said to be *opaque* (or not transparent) to cut.
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/primitive/testutils/CallUtils.kt:132:     * Utility function to test whether the cause of errors generated is correctly filled
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/primitive/testutils/CallUtils.kt:135:     * in the end the generated solution's error chain is checked to match with [expectedErrorSolution]'s chain
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/primitive/testutils/CatchUtils.kt:85:            .filter { (_, solutionList) -> solutionList.none { it is Solution.Halt } }
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/integrationtest/StateIntegrationTesting.kt:70:                        (it as? Solution.Yes)?.copy(substitution = it.substitution.filter { _, t -> t !is Var }) ?: it
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/testutils/StateUtils.kt:28:        assertTrue { actualNextStateSequence.single() is S }
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/testutils/StateUtils.kt:33:        assertTrue("Expected state type to be ${S::class} but was ${state::class}") { state is S }
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/testutils/StateUtils.kt:52:        is Solve.Response -> sideEffectManager
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/testutils/StateUtils.kt:53:        is Solve.Request<*> -> context.getSideEffectManager()
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/streams/solver/fsm/impl/testutils/StateUtils.kt:54:    } ?: fail("SideEffectManager is not present in $this")
solve-streams/src/commonTest/kotlin/it/unibo/tuprolog/solve/TestStaticFactory.kt:17:        assertTrue { solver is StreamsSolver }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/DummyInstances.kt:15: * Utils singleton that contains dummy instances, to be used when in a test something is not important
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestAbolishImpl.kt:86:            val query = (current_prolog_flag("max_arity", A) and ((X `is` (A + 1)) and abolish("foo" / X)))
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestAbolish.kt:42:     * ?- (current_prolog_flag(max_arity,A), X is A + 1, abolish(foo/X)).
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestBigListImpl.kt:18:                        M `is` (N - 1),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestDirectivesImpl.kt:212:                assertTrue { events[0] is InitializationIssue }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestDirectivesImpl.kt:226:        theoryOf(directive { initGoal(X `is` (Y + 1)) })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestDirectivesImpl.kt:240:                assertTrue { events[0] is InitializationIssue }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestFlagsImpl.kt:72:                assertTrue { sol.substitution[F] is Atom }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestFunctorImpl.kt:273:                (X `is` (A + 1)) and functor(T, "foo", X)
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestFunctor.kt:157:     * ?- (current_prolog_flag(max_arity,A), X is A + 1, functor(T, foo, X)).
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestingClauseTheories.kt:343:     *       M1 is M + 1,
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestingClauseTheories.kt:354:                            ("M1" `is` (varOf("M") + 1)) and
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIsImpl.kt:12:            val query = "Result" `is` (numOf(3) + realOf(11.0))
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIsImpl.kt:26:            val query = ("X" `=` (intOf(1) + intOf(2))) and ("Y" `is` ("X" * intOf(3)))
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIsImpl.kt:40:            val query = "foo" `is` intOf(77)
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIsImpl.kt:54:            val query = intOf(77) `is` "N"
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIsImpl.kt:62:                            Signature("is", 2),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIsImpl.kt:77:            val query = intOf(77) `is` "foo"
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIsImpl.kt:85:                            Signature("is", 2),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIsImpl.kt:101:            val query = "X" `is` float(intOf(3))
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIs.kt:12:     * ?- 'is'(Result,3 + 11.0).
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIs.kt:22:     * ?- (X = 1 + 2, 'is'(Y, X * 3)).
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIs.kt:32:     * ?- 'is'(foo,77).
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIs.kt:41:     * ?- 'is'(77, N).
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIs.kt:51:     * ?- 'is'(77, foo).
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestIs.kt:61:     * ?- 'is'(X,float(3)).
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestRecursionImpl.kt:28:                    T `is` (X - 1),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestRecursionImpl.kt:39:                    T `is` (X + 1),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestRecursionImpl.kt:102:                    M `is` (N - 1),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolutionPresentationImpl.kt:17:            assertTrue { sol is Solution.Yes }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:233:            assertTrue { observedWarnings[0] is MissingPredicate }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:695:                                        expectedSolutions.any { it is Solution.Halt } ->
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:788:                                        it is Solution.Halt &&
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:790:                                            it.exception !is TimeOutException
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:841:                                    expectedSolutions.first() is Solution.Yes -> hasSolutions({ no() })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:842:                                    expectedSolutions.first() is Solution.No -> hasSolutions({ yes() })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:848:                                    expectedSolutions.first() is Solution.Yes -> hasSolutions({ no() })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:849:                                    expectedSolutions.first() is Solution.No -> hasSolutions({ yes() })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:855:                                    expectedSolutions.first() is Solution.Yes -> hasSolutions({ yes() })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:856:                                    expectedSolutions.first() is Solution.No -> hasSolutions({ no() })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:862:                                    expectedSolutions.first() is Solution.Yes -> hasSolutions({ yes() })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestSolverImpl.kt:863:                                    expectedSolutions.first() is Solution.No -> hasSolutions({ no() })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestStackTraceImpl.kt:26:            val solver = solverFactory.solverWithDefaultBuiltins(staticKb = threeLayersTheory { X `is` (Y + 1) })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestStackTraceImpl.kt:43:                ktListOf("is" / 2, "baz" / 1, "bar" / 1, "foo" / 1, "?-" / 1),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestStackTraceImpl.kt:52:            val solver = solverFactory.solverWithDefaultBuiltins(staticKb = threeLayersTheory { X `is` (Y + 1) })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestStackTraceImpl.kt:69:                ktListOf("is" / 2, "baz" / 1, "bar" / 1, "foo" / 1, "findall" / 3, "?-" / 1),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestStackTraceImpl.kt:78:            val solver = solverFactory.solverWithDefaultBuiltins(staticKb = threeLayersTheory { X `is` (Y + 1) })
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestStackTraceImpl.kt:95:                ktListOf("is" / 2, "baz" / 1, "bar" / 1, "foo" / 1, "bagof" / 3, "findall" / 3, "?-" / 1),
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:57:        assertTrue("Thrown error `${error::class}` is not of expected type `${E::class}`") { error is E }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:64: * 1) In case of a [Solution.halt], the contained exception is checked only to be of the correct expected class
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:80:        expected is Solution.Halt -> {
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:84:            assertTrue(reportMsg(expected, actual, "Solution is not Halt")) { actual is Solution.Halt }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:91:                is PrologError -> {
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:96:                            "Exception is not PrologError"
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:98:                    ) { actual.exception is PrologError }
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:139: * @param equalityAssertion the equality assertion is delegated to [assertSolutionEquals] by default
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:198:            is Solution.Yes -> {
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:202:            is Solution.Halt -> println("halt.\n\t${it.exception}")
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TestUtils.kt:203:            is Solution.No -> println("no.")
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TimeRelatedTheories.kt:35:     * thus a [TimeOutException] is returned as the first solution
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TimeRelatedTheories.kt:51:     * thus a [TimeOutException] is returned as the second solution
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TimeRelatedTheories.kt:68:     * thus a [TimeOutException] is returned as the third solution
test-solve/src/commonMain/kotlin/it/unibo/tuprolog/solve/TimeRelatedTheories.kt:85:     * thus no [TimeOutException] is returned and 3 positive solutions are returned instead
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/function/testutils/ExpressionEvaluatorUtils.kt:33:    /** Test data is in the form (input, transforming function, expected output) */
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/magic/MagicCutTest.kt:21:            Atom.of("!") !is MagicCut
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/magic/MagicCutTest.kt:24:            Atom.of("¡") !is MagicCut
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/IsTest.kt:24:                is Substitution.Unifier -> {
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/IsTest.kt:27:                            it is Solution.Yes
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/IsTest.kt:32:                is Substitution.Fail -> {
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/IsTest.kt:35:                            it is Solution.No
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/BinaryRelationUtils.kt:23:            termRelation.wrappedImplementation(input).single().solution is Solution.Yes
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/BinaryRelationUtils.kt:26:            termRelation.wrappedImplementation(input).single().solution is Solution.No
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TermOrderingUtils.kt:29:            standardOrderRelation.wrappedImplementation(input).single().solution is Solution.Yes
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TermOrderingUtils.kt:32:            standardOrderRelation.wrappedImplementation(input).single().solution is Solution.No
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:97:            is Numeric -> false
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:98:            is Struct -> when {
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:109:        typeTest(AtomPrimitive.functor) { it is Atom }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:113:        typeTest(Atomic.functor) { it is Constant }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:117:        typeTest(Callable.functor) { it is Struct }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:121:        typeTest(Compound.functor) { it is Struct && it.arity > 0 }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:130:                request.arguments[0] is Var -> InstantiationError::class
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:138:        typeTest(FloatPrimitive.functor) { it is Real }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:146:        typeTest(IntegerPrimitive.functor) { it is Integer }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:150:        typeTest(NonVar.functor) { it !is Var }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:154:        typeTest(NumberTerm.functor) { it is Numeric }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:158:        typeTest(VarPrimitive.functor) { it is Var }
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:168:            unaryPredicate.wrappedImplementation(input).single().solution is Solution.Yes
test-solve/src/commonTest/kotlin/it/unibo/tuprolog/solve/stdlib/primitive/testutils/TypeTestingUtils.kt:171:            unaryPredicate.wrappedImplementation(input).single().solution is Solution.No
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/impl/MutableReteClauseMultiSet.kt:29:        return if (other is MutableClauseMultiSet) {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/impl/MutableReteClauseQueue.kt:54:        return if (other is MutableClauseQueue) {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/impl/ReteClauseMultiSet.kt:38:        return if (other is ClauseMultiSet && other !is MutableClauseMultiSet) {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/impl/ReteClauseQueue.kt:61:        return if (other is ClauseQueue && other !is MutableClauseQueue) {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/clause/SituatedIndexedClause.kt:9:    /**Effectfully removes this [Clause] from whatever it is situated*/
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/clause/SituatedIndexedClause.kt:38:                    if (other !is SituatedIndexedClause) return false
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/IndexingLeaf.kt:11:     * such a condition is never met. The concept of "first" may vary between implementations */
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/leaf/CompoundIndex.kt:160:        this.head!!.nestedFirstArgument(nestingLevel) is Var
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:106:            is Numeric -> {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:112:            is Atom -> {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:118:            is Var -> {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:136:            is Numeric -> Utils.flattenIndexed(
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:140:            is Atom -> Utils.flattenIndexed(
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:144:            is Var -> Utils.flattenIndexed(
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:158:            is Numeric ->
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:163:            is Atom ->
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:168:            is Var ->
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:184:            is Numeric -> Utils.flattenIndexed(
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:188:            is Atom -> Utils.flattenIndexed(
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:192:            is Var -> Utils.flattenIndexed(
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:206:            is Numeric -> {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:210:            is Atom -> {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:214:            is Var -> {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:228:            is Numeric -> {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:234:            is Atom -> {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:240:            is Var -> Utils.comparePriority(
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:288:            is Numeric -> numericIndex
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:289:            is Atom -> atomicIndex
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:290:            is Var -> variableIndex
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FamilyArityReteNode.kt:295:        this.head!!.nestedFirstArgument(nestingLevel + 1) is Var
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/nodes/FunctorIndexingNode.kt:108:        this is Rule && this.head.nestedFirstArgument(nestingLevel) is Var
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/ReteTree.kt:11:    /**Returns all the [Clause] this [ReteTree] is storing*/
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/ReteTree.kt:21:    /**Tells if the given [Clause] is stored in this [ReteTree]*/
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/Utils.kt:27:     * No checks are performed upon the validity of the Struct this extension method is called upon. */
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/Utils.kt:34:     * No checks are performed upon the validity of the Struct this extension method is called upon. */
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/Utils.kt:41:     * No checks are performed upon the validity of the Struct this extension method is called upon. */
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/Utils.kt:48:            while (currentTerm is Struct) {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/custom/Utils.kt:91:    /**Compares two nullable [SituatedIndexedClause]. If both are null, null is returned*/
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/generic/AbstractIntermediateReteNode.kt:23:        filterValues { node -> node is ChildNodeType }
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/generic/AbstractReteNode.kt:17:    /** Called when a non-zero-limit removal is required inside a node */
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/generic/set/RootNode.kt:17:            is Directive ->
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/generic/set/RootNode.kt:20:            is Rule -> element.head.functor.let {
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/generic/set/RootNode.kt:31:                is Directive -> children[null]
theory/src/commonMain/kotlin/it/unibo/tuprolog/collections/rete/generic/set/RootNode.kt:32:                is Rule -> children[element.head.functor]
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/AbstractTheory.kt:29:        require(indicator.isWellFormed) { "The provided indicator is not well formed: $indicator" }
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/AbstractTheory.kt:40:        require(indicator.isWellFormed) { "The provided indicator is not well formed: $indicator" }
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/AbstractTheory.kt:56:        if (other !is Theory) return false
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/impl/IndexedTheory.kt:38:            is RetrieveResult.Failure ->
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/impl/IndexedTheory.kt:54:            if (result is RetrieveResult.Success) {
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/impl/IndexedTheory.kt:71:            is RetrieveResult.Failure -> RetractResult.Failure(this)
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/impl/MutableIndexedTheory.kt:46:            is RetrieveResult.Success -> RetractResult.Success(this@MutableIndexedTheory, clauses)
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/RetractResult.kt:9:    /** The result always present value, is the clause database resulting from the operation execution */
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/Theory.kt:55:    /** Checks if given clause is contained in this theory */
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/Theory.kt:59:    /** Checks if given clause is present in this theory */
theory/src/commonMain/kotlin/it/unibo/tuprolog/theory/Theory.kt:140:    /** An enhanced toString that prints the theory in a Prolog program format, if [asPrologText] is `true` */
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/prototypes/PrototypeClauseMultiSetTestImpl.kt:42:            is RetrieveResult.Success -> res.clauses.asSequence()
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/prototypes/PrototypeClauseQueueTestImpl.kt:76:            is RetrieveResult.Success -> res.clauses.asSequence()
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/custom/ReteTreeAssertionUtils.kt:79:                fail(message?.invoke(e) ?: "Item $e is out of sequence")
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/custom/ReteTreeAssertionUtils.kt:114:                fail(message?.invoke(e) ?: "Item $e is not present")
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/custom/ReteTreeAssertionUtils.kt:138:                fail(message?.invoke(clause) ?: "Item $clause is already present")
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/ArgNodeTest.kt:80:        // notice that no check is made, at this level, to ensure that inserted clause has correct "term" at correct "index"
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/ArgNodeTest.kt:98:        // note that no check is made, at this level, to guarantee that no args headed rules should not be inserted there
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/ArityNodeTest.kt:71:        // notice that no check is made, at this level, to ensure that inserted clause has correct "arity"
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/ArityNodeTest.kt:156:                init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/ArityNodeTest.kt:169:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/ArityNodeTest.kt:180:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/DirectiveNodeTest.kt:92:                init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/DirectiveNodeTest.kt:103:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/DirectiveNodeTest.kt:112:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/FunctorNodeTest.kt:108:                init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/FunctorNodeTest.kt:121:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/FunctorNodeTest.kt:132:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/NoArgsNodeTest.kt:52:        // no check is present to ensure that a correct clause is inserted as a child
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/NoArgsNodeTest.kt:96:                init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/NoArgsNodeTest.kt:107:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/NoArgsNodeTest.kt:118:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/RootNodeTest.kt:120:                init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/RootNodeTest.kt:133:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/RootNodeTest.kt:144:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/RuleNodeTest.kt:92:                init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/RuleNodeTest.kt:103:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/collections/rete/nodes/set/RuleNodeTest.kt:112:            init() // because removal of side-effects is needed
theory/src/commonTest/kotlin/it/unibo/tuprolog/testutils/ClauseAssertionUtils.kt:43:                expected is Var && actual is Var -> {
theory/src/commonTest/kotlin/it/unibo/tuprolog/testutils/ClauseAssertionUtils.kt:46:                expected is Constant && actual is Constant -> {
theory/src/commonTest/kotlin/it/unibo/tuprolog/testutils/ClauseAssertionUtils.kt:49:                expected is Struct && actual is Struct -> {
theory/src/commonTest/kotlin/it/unibo/tuprolog/testutils/ReteNodeUtils.kt:126:    /** Asserts that rete node is empty */
theory/src/commonTest/kotlin/it/unibo/tuprolog/testutils/ReteNodeUtils.kt:249:                clauseHead?.let { clause is Rule && it structurallyEquals clause.head }
theory/src/commonTest/kotlin/it/unibo/tuprolog/testutils/TheoryUtils.kt:25:    /** Contains well formed clauses (the head is a [Struct] and the body doesn't contain [Numeric] values) */
theory/src/commonTest/kotlin/it/unibo/tuprolog/testutils/TheoryUtils.kt:40:            .filterKeys { it is Rule && it.body.isVariable }
theory/src/commonTest/kotlin/it/unibo/tuprolog/testutils/TheoryUtils.kt:45:        get() = rulesQueryWithVarBodyResultsMap.filterKeys { rule -> rule.head.argsSequence.all { it is Var } }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:185:            clausesQueryResultsMap.filterKeys { it is Rule }.mapKeys { it.key as Rule }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:196:            clausesQueryResultsMap.filterKeys { it is Rule }.mapKeys { it.key as Rule }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:275:        if (filledTheory is MutableTheory) {
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:283:        if (filledTheory is MutableTheory) {
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:340:                if (result.isEmpty()) assertTrue { retractResult is RetractResult.Failure }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:341:                else assertTrue { retractResult is RetractResult.Success }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:361:                if (result.isEmpty()) assertTrue { retractResult is RetractResult.Failure }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:362:                else assertTrue { retractResult is RetractResult.Success }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:401:                if (result.isEmpty()) assertTrue { retractResult is RetractResult.Failure }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:402:                else assertTrue { retractResult is RetractResult.Success }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:422:                if (result.isEmpty()) assertTrue { retractResult is RetractResult.Failure }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:423:                else assertTrue { retractResult is RetractResult.Success }
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:439:        if (first is MutableTheory && second is MutableTheory) {
theory/src/commonTest/kotlin/it/unibo/tuprolog/theory/PrototypeTheoryTest.kt:441:        } else if (first !is MutableTheory && second !is MutableTheory) {
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:8: * @param K is the type of the keys used for indexing items in this cache
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:9: * @param V is the type of the values stored in this cache
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:25:     * @param key is the key used for indexing the pair
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:26:     * @param value is the value corresponding to [key]
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:33:     * @param key is the key used for indexing the pair
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:39:     * Retrieves the cached value corresponding to the provided [key], or stores a cache for the key in case it is missing
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:40:     * @param key is the key used for indexing the pair
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:41:     * @param valueGenerator is the function aimed at generating the value to be cached
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Cache.kt:46:            is Optional.Some -> got.value
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Castable.kt:10:     * @throws ClassCastException if the current object is not an instance of [U]
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/Castable.kt:17:     * @return the current object, casted to [U], or `null`, if the current object is not an instance of [U]
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/impl/ConjunctionCursor.kt:12:            second is LazyCursor -> second.next
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/impl/LRUCache.kt:28:            if (evictedKey is Optional.Some) {
utils/src/commonMain/kotlin/it/unibo/tuprolog/utils/impl/MapperCursor.kt:11:        require(wrapped !is EmptyCursor) {
utils/src/commonTest/kotlin/it/unibo/tuprolog/utils/TestCursor.kt:22:                current.next is Cursor<out T>
