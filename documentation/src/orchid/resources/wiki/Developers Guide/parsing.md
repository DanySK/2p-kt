# Parsing

## Modules overview

Parsing Prolog terms and theories is the purpose of the `parser-core` and `parser-theory` modules, respectively.
Both modules leverage on ANTLR for parsing strings, behind the scenes, but they only expose an ANTLR-agnostic public API.
Users of 2P-Kt will only rely on types and methods from these modules to parse their Prolog strings.
In principle, if the ANTLR technology is replaced in the future, the public API of the `parser-core` and `parser-theory` 
modules should not change at all.

ANTLR is a parser generator capable of producing Java or JavaScript (JS) code, i.e., platform-specific sources.
Any parser generated by ANTLR requires a _runtime_ library to actually function in production.
There are many platform-specific _runtime_ libraries (or simply "runtimes", henceforth).
Of course, Java-based parser require the Java runtime (that is, a Java library), whereas JS-based parsers require the JS
runtime, (that is, a JS library). 

To handle such complexity, we introduced two more modules, namely, `parser-jvm` and `parser-js`.
They are two Kotlin platform-specific projects.
In particular, `parser-jvm` is a Kotlin/JVM project, whereas `parser-js` is a Kotlin/JS project.
They are to be considered _implementation_ modules and they must only depend on their respective ANTLR runtime.
Accordingly, they must NOT depend on any other module in 2P-Kt.

## Proposed Work plan

1. Understand the architecture and rationale of parsing in [2P-classic](https://gitlab.com/pika-lab/tuprolog/2p)
    * Consider both modules `parser` and `core`
    
0. Describe the architecture, rationale and functioning by extending this page & producing
    * Then check your comprehension by interacting with the teachers

0. Define a suite of platform independent tests to be placed in `parser-core/commonMain/test` and `parser-theory/commonMain/test`
    * You can take inspiration from tests in 2P-classic's `core` and `parser` modules
    * Ensure the test suites are ok by interacting with the teachers

0. Proceed by reproducing the parsing strategy of 2P-classic in module `parser-jvm` and `parser-core`
    * Notice that some ANTLR-related code has already been copy-pasted & adapted in `parser-jvm`

0. Ensure tests are satisfied for JVM parsing

0. Proceed by reproducing the parsing strategy of 2P-classic in module `parser-js` and `parser-core`
    * Notice that some ANTLR-related code has already been copy-pasted & adapted in `parser-js`

0. Ensure tests are satisfied for JS parsing

0. Document and describe the produced code and its rationale using kotlindoc and this page

##Work


- Added "expect fun TermParser.Companion.withX() : TermParser" in TermParser.kt in `parser-core`
- Added the "actual" functions in the correspondents `jvmMain` and `jsMain`
- Added "expect fun ClauseDatabaseParser.Companion.withX() : ClauseDatabaseParser" in ClauseDatabaseParser.kt in `parser-theory`
- Added the "actual" functions in the correspondents `jvmMain` and `jsMain`
- Implemented TermParser in `jvmMain` TermParserImpl and developed parse method
- Added PrologParserFactory interface in `jvmMain` with parse methods and Singleton Pattern
- Implemented PrologParserFactory with a Singleton Impl and with Kotlin's methods and structures
- Implemented DynamicOpListener: PrologParserBaseListener
- Implemented PrologExpressionVisitor: PrologParserBaseVisitor with new structures of the core project, like List or Scope

From these activities I learned a lot of Kotlin's features:
- I now know how to develop and use a Singleton object (using "object" keyword)
- As suggested by Giovanni Ciatto, I can also define an invoke operator to simplify objects creation (for example in ParserPrologFactory -> invoke() PrologParserFactory = PrologParserFactoryImpl)
- I could appreciate the non-verbose Kotlin syntax, for example function with an expression body and inferred return type could be: `fun add(a: Int, b: Int) = a + b`
- Everything is an expression: it simplify every methods based on if/else statement: `fun max(a: Int,b: Int) if(a>b) a else b`
- "when" Control flow: it is a substitution of the old-style "switch" and simplifies it: for example, a 21 lines Java if/else method has become in Kotlin only 6 lines
- Kotlin Multi-platform: awareness of use "expect/actual" multi-platform keywords. 
- Use of "Scope" interface to optimize stateful features

Then I started implementing tests
- Implemented PrologParserTest in `parser-jvm/test`
- Implemented Term/ExpressionParserTest in `parser-core/commonTest`
- Using of Prolog dsl: learned how to use it, for example ( "PrologActualString" to prolog { "expected" })
- "a" and "B" are automatically translated in Atom and Var
- `"a :- b"` can be translated as `"a" impliedBy "b"`
- `" a; B :- 1, 3.1; '2'"` can be translated as `"a" or "B" impliedBy ((1 and 3.1) or "2")`. `or`, `and`, `impliedBy` are keywords of prolog dsl
    and those are generated by method extensions and infix Kotlin keyword (we can define new infix operator). For example:  `infix fun Any.or(other: Any): Struct = structOf(";", this.toTerm(), other.toTerm())`

After I started developing `parser-js` module
- I immediately concentrated on the Lexer: in fact, it was missing of DynamicLexer and all his features
- I changed something in the PrologLexer.g4 to adapt it 